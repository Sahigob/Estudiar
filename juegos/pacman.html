 ctx.arc(ghost.x * CELL_SIZE + 7, ghost.y * CELL_SIZE + 8, 1, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(ghost.x * CELL_SIZE + 13, ghost.y * CELL_SIZE + 8, 1, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }

        function updatePacman() {
            // LÃ³gica de movimiento
            if (canMove(pacman.x, pacman.y, pacman.nextDir)) {
                pacman.dir = pacman.nextDir;
            }
            
            if (canMove(pacman.x, pacman.y, pacman.dir)) {
                const newPos = moveEntity(pacman, pacman.dir);
                pacman.x = newPos.x;
                pacman.y = newPos.y;
            }

            // Comer puntos
            for (let i = dots.length - 1; i >= 0; i--) {
                if (dots[i].x === pacman.x && dots[i].y === pacman.y) {
                    if (dots[i].type === 'power') {
                        score += 50;
                        scared = true;
                        scaredTimer = 6000;
                    } else {
                        score += 10;
                    }
                    dots.splice(i, 1);
                    document.getElementById('score').textContent = 'Score: ' + score;
                }
            }
        }

        function updateGhosts() {
            ghosts.forEach(ghost => {
                const possibleDirs = ['up', 'down', 'left', 'right'].filter(d => 
                    canMove(ghost.x, ghost.y, d)
                );
                
                if (possibleDirs.length === 0) return;
                
                if (!canMove(ghost.x, ghost.y, ghost.dir) || Math.random() < 0.1) {
                    ghost.dir = possibleDirs[Math.floor(Math.random() * possibleDirs.length)];
                }
                
                const newPos = moveEntity(ghost, ghost.dir);
                ghost.x = newPos.x;
                ghost.y = newPos.y;
            });
        }

        function checkCollisions() {
            ghosts.forEach(ghost => {
                if (ghost.x === pacman.x && ghost.y === pacman.y) {
                    if (scared) {
                        score += 200;
                        document.getElementById('score').textContent = 'Score: ' + score;
                        // Reiniciar fantasma a su posiciÃ³n inicial
                        ghost.x = 14;
                        ghost.y = 14;
                    } else {
                        endGame(false);
                    }
                }
            });

            if (dots.length === 0) {
                endGame(true);
            }
        }

        function endGame(won) {
            gameOver = true;
            document.getElementById('gameOverText').textContent = won ? 'Â¡GANASTE!' : 'GAME OVER';
            document.getElementById('finalScore').textContent = 'Score Final: ' + score;
            document.getElementById('gameOver').style.display = 'block';
        }

        function resetGame() {
            pacman = { x: 14, y: 23, dir: 'right', nextDir: 'right' };
            ghosts = [
                { x: 12, y: 14, color: '#FF0000', dir: 'up' },
                { x: 14, y: 14, color: '#FFB8FF', dir: 'down' },
                { x: 15, y: 14, color: '#00FFFF', dir: 'left' },
                { x: 16, y: 14, color: '#FFB852', dir: 'right' }
            ];
            initDots();
            score = 0;
            gameOver = false;
            scared = false;
            scaredTimer = 0;
            animationFrame = 0;
            document.getElementById('score').textContent = 'Score: 0';
            document.getElementById('gameOver').style.display = 'none';
            gameLoop();
        }

        // ðŸš¨ FUNCIÃ“N CRUCIAL: Limpieza y Bucle del Juego
        function gameLoop() {
            if (gameOver) return;

            // âœ… SOLUCIÃ“N AL EFECTO FANTASMA: Borrado rÃ¡pido del canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height); 
            
            drawMaze();
            drawDots();
            drawGhosts();
            drawPacman();

            animationFrame++;
            if (animationFrame % 10 === 0) {
                mouthOpen = !mouthOpen;
                updatePacman();
                updateGhosts();
                checkCollisions();

                if (scared) {
                    scaredTimer -= 100;
                    if (scaredTimer <= 0) {
                        scared = false;
                    }
                }
            }

            requestAnimationFrame(gameLoop);
        }

        // =======================================================
        // ðŸ•¹ï¸ LÃ“GICA DEL JOYSTICK TÃCTIL (MÃ‰TODO SWIPE)
        // =======================================================

        canvas.addEventListener('touchstart', (e) => {
            if (gameOver) return;
            e.preventDefault();
            // Guarda la posiciÃ³n inicial del toque
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        });

        canvas.addEventListener('touchend', (e) => {
            if (gameOver) return;
            e.preventDefault();
            
            // Obtener la posiciÃ³n final al levantar el dedo
            // Nota: touchend no tiene touches[], usamos la posiciÃ³n de touchend
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;

            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;

            // Determinar si el movimiento fue horizontal o vertical
            if (Math.abs(deltaX) > SWIPE_THRESHOLD || Math.abs(deltaY) > SWIPE_THRESHOLD) {
                if (Math.abs(deltaX) > Math.abs(deltaY)) {
                    // Movimiento horizontal (Izquierda/Derecha)
                    if (deltaX > 0) pacman.nextDir = 'right';
                    else pacman.nextDir = 'left';
                } else {
                    // Movimiento vertical (Arriba/Abajo)
                    if (deltaY > 0) pacman.nextDir = 'down';
                    else pacman.nextDir = 'up';
                }
            }
        });

        // Controles de Teclado (para PC)
        document.addEventListener('keydown', (e) => {
            if (gameOver) return;
            if (e.key === 'ArrowUp') pacman.nextDir = 'up';
            if (e.key === 'ArrowDown') pacman.nextDir = 'down';
            if (e.key === 'ArrowLeft') pacman.nextDir = 'left';
            if (e.key === 'ArrowRight') pacman.nextDir = 'right';
        });

        document.getElementById('restartBtn').addEventListener('click', resetGame);

        initDots();
        gameLoop();
    </script>
</body>
</html>
