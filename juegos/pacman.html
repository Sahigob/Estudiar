<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pac-Man Game</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      min-height: 100vh;
      background-color: #000;
      font-family: Arial, sans-serif;
      color: white;
      padding: 20px 0;
    }

    #score {
      font-size: 24px;
      font-weight: bold;
      margin-bottom: 10px;
    }

    #gameCanvas {
      border: 4px solid #1e40af;
      background-color: #000;
      display: block;
    }

    #controls {
      margin-top: 10px;
      text-align: center;
    }

    #touchControls {
      margin-top: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }

    .control-row {
      display: flex;
      gap: 10px;
    }

    .control-btn {
      width: 60px;
      height: 60px;
      font-size: 24px;
      font-weight: bold;
      background-color: #FFD700;
      border: none;
      border-radius: 10px;
      color: #000;
      cursor: pointer;
    }

    .control-btn:active {
      background-color: #FFC700;
    }

    #gameOver {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(0, 0, 0, 0.9);
      padding: 40px;
      border-radius: 10px;
      text-align: center;
      z-index: 10;
    }

    #gameOver h2 {
      color: #FFD700;
      font-size: 48px;
      margin-bottom: 20px;
    }

    #gameOver p {
      font-size: 24px;
      margin-bottom: 20px;
    }

    #restartBtn {
      padding: 15px 30px;
      font-size: 18px;
      background-color: #FFD700;
      color: #000;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
    }

    #restartBtn:hover {
      background-color: #FFC700;
    }

    .info {
      font-size: 14px;
      color: #999;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <div id="score">Score: 0</div>
  <canvas id="gameCanvas"></canvas>
  <div id="controls">
    <p>Usa las flechas del teclado o los botones para moverte</p>
    <p class="info">Come todos los puntos y evita los fantasmas</p>
  </div>
  <div id="touchControls">
    <div class="control-row">
      <button class="control-btn" onclick="setDirection('up')">↑</button>
    </div>
    <div class="control-row">
      <button class="control-btn" onclick="setDirection('left')">←</button>
      <button class="control-btn" onclick="setDirection('down')">↓</button>
      <button class="control-btn" onclick="setDirection('right')">→</button>
    </div>
  </div>
  <div id="gameOver">
    <h2 id="gameOverText">GAME OVER</h2>
    <p id="finalScore">Score Final: 0</p>
    <button id="restartBtn">Jugar de Nuevo</button>
  </div>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const CELL_SIZE = 20;
    const GRID_WIDTH = 28;
    const GRID_HEIGHT = 31;

    function resizeCanvas() {
      const baseWidth = GRID_WIDTH * CELL_SIZE;
      const baseHeight = GRID_HEIGHT * CELL_SIZE;
      const maxWidth = window.innerWidth * 0.9;
      const scale = Math.min(maxWidth / baseWidth, 1);
      canvas.width = baseWidth * scale;
      canvas.height = baseHeight * scale;
      ctx.setTransform(scale, 0, 0, scale, 0, 0);
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    function setDirection(dir) {
      if (!gameOver) {
        pacman.nextDir = dir;
      }
    }

    const MAZE = [
      "############################",
      "#............##............#",
      "#.####.#####.##.#####.####.#",
      "#o####.#####.##.#####.####o#",
      "#.####.#####.##.#####.####.#",
      "#..........................#",
      "#.####.##.########.##.####.#",
      "#.####.##.########.##.####.#",
      "#......##....##....##......#",
      "######.##### ## #####.######",
      "######.##### ## #####.######",
      "######.##          ##.######",
      "######.## ###--### ##.######",
      "######.## #      # ##.######",
      "      .   #      #   .      ",
      "######.## #      # ##.######",
      "######.## ######## ##.######",
      "######.##          ##.######",
      "######.## ######## ##.######",
      "######.## ######## ##.######",
      "#............##............#",
      "#.####.#####.##.#####.####.#",
      "#.####.#####.##.#####.####.#",
      "#o..##.......  .......##..o#",
      "###.##.##.########.##.##.###",
      "###.##.##.########.##.##.###",
      "#......##....##....##......#",
      "#.##########.##.##########.#",
      "#.##########.##.##########.#",
      "#..........................#",
      "############################"
    ];

    let pacman = { x: 14, y: 23, dir: 'right', nextDir: 'right' };
    let ghosts = [
      { x: 12, y: 14, color: '#FF0000', dir: 'up' },
      { x: 14, y: 14, color: '#FFB8FF', dir: 'down' },
      { x: 15, y: 14, color: '#00FFFF', dir: 'left' },
      { x: 16, y: 14, color: '#FFB852', dir: 'right' }
    ];
    let dots = [];
    let score = 0;
    let gameOver = false;
    let scared = false;
    let scaredTimer = 0;
    let mouthOpen = true;
    let animationFrame = 0;

    function initDots() {
      dots = [];
      for (let y = 0; y < GRID_HEIGHT; y++) {
        for (let x = 0; x < GRID_WIDTH; x++) {
          const cell = MAZE[y][x];
          if (cell === '.') dots.push({ x, y, type: 'dot' });
          if (cell === 'o') dots.push({ x, y, type: 'power' });
        }
      }
    }
    function drawMaze() {
      for (let y = 0; y < GRID_HEIGHT; y++) {
        for (let x = 0; x < GRID_WIDTH; x++) {
          if (MAZE[y][x] === '#') {
            ctx.fillStyle = '#1e3a8a';
            ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
          }
        }
      }
    }

    function drawDots() {
      dots.forEach(dot => {
        ctx.fillStyle = '#FFB897';
        ctx.beginPath();
        const radius = dot.type === 'power' ? 5 : 2;
        ctx.arc(dot.x * CELL_SIZE + 10, dot.y * CELL_SIZE + 10, radius, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function drawPacman() {
      ctx.save();
      ctx.translate(pacman.x * CELL_SIZE + 10, pacman.y * CELL_SIZE + 10);

      let rotation = 0;
      if (pacman.dir === 'up') rotation = -Math.PI / 2;
      if (pacman.dir === 'down') rotation = Math.PI / 2;
      if (pacman.dir === 'left') rotation = Math.PI;
      ctx.rotate(rotation);

      ctx.fillStyle = '#FFFF00';
      ctx.beginPath();

      if (mouthOpen) {
        ctx.arc(0, 0, 10, 0.2 * Math.PI, 1.8 * Math.PI);
        ctx.lineTo(0, 0);
      } else {
        ctx.arc(0, 0, 10, 0, Math.PI * 2);
      }

      ctx.fill();
      ctx.restore();
    }

    function drawGhosts() {
      ghosts.forEach(ghost => {
        ctx.fillStyle = scared ? '#0000FF' : ghost.color;

        ctx.beginPath();
        ctx.arc(ghost.x * CELL_SIZE + 10, ghost.y * CELL_SIZE + 8, 8, Math.PI, 0, false);
        ctx.lineTo(ghost.x * CELL_SIZE + 18, ghost.y * CELL_SIZE + 18);
        ctx.lineTo(ghost.x * CELL_SIZE + 15, ghost.y * CELL_SIZE + 15);
        ctx.lineTo(ghost.x * CELL_SIZE + 12, ghost.y * CELL_SIZE + 18);
        ctx.lineTo(ghost.x * CELL_SIZE + 9, ghost.y * CELL_SIZE + 15);
        ctx.lineTo(ghost.x * CELL_SIZE + 6, ghost.y * CELL_SIZE + 18);
        ctx.lineTo(ghost.x * CELL_SIZE + 3, ghost.y * CELL_SIZE + 15);
        ctx.lineTo(ghost.x * CELL_SIZE + 2, ghost.y * CELL_SIZE + 18);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(ghost.x * CELL_SIZE + 7, ghost.y * CELL_SIZE + 8, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(ghost.x * CELL_SIZE + 13, ghost.y * CELL_SIZE + 8, 2, 0, Math.PI * 2);
        ctx.fill();

        if (!scared) {
          ctx.fillStyle = 'black';
          ctx.beginPath();
          ctx.arc(ghost.x * CELL_SIZE + 7, ghost.y * CELL_SIZE + 8, 1, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(ghost.x * CELL_SIZE + 13, ghost.y * CELL_SIZE + 8, 1, 0, Math.PI * 2);
          ctx.fill();
        }
      });
    }

    function canMove(x, y, dir) {
      let newX = x, newY = y;
      if (dir === 'up') newY--;
      if (dir === 'down') newY++;
      if (dir === 'left') newX--;
      if (dir === 'right') newX++;

      if (newX < 0) newX = GRID_WIDTH - 1;
      if (newX >= GRID_WIDTH) newX = 0;

      return MAZE[newY] && MAZE[newY][newX] !== '#';
    }

    function moveEntity(entity, dir) {
      let { x, y } = entity;
      if (dir === 'up') y--;
      if (dir === 'down') y++;
      if (dir === 'left') x--;
      if (dir === 'right') x++;

      if (x < 0) x = GRID_WIDTH - 1;
      if (x >= GRID_WIDTH) x = 0;

      return { x, y };
    }
    function updatePacman() {
      if (canMove(pacman.x, pacman.y, pacman.nextDir)) {
        pacman.dir = pacman.nextDir;
      }

      if (canMove(pacman.x, pacman.y, pacman.dir)) {
        const newPos = moveEntity(pacman, pacman.dir);
        pacman.x = newPos.x;
        pacman.y = newPos.y;
      }

      for (let i = dots.length - 1; i >= 0; i--) {
        if (dots[i].x === pacman.x && dots[i].y === pacman.y) {
          if (dots[i].type === 'power') {
            score += 50;
            scared = true;
            scaredTimer = 6000;
          } else {
            score += 10;
          }
          dots.splice(i, 1);
          document.getElementById('score').textContent = 'Score: ' + score;
        }
      }
    }

    function updateGhosts() {
      ghosts.forEach(ghost => {
        const possibleDirs = ['up', 'down', 'left', 'right'].filter(d =>
          canMove(ghost.x, ghost.y, d)
        );

        if (possibleDirs.length === 0) return;

        if (!canMove(ghost.x, ghost.y, ghost.dir) || Math.random() < 0.1) {
          ghost.dir = possibleDirs[Math.floor(Math.random() * possibleDirs.length)];
        }

        const newPos = moveEntity(ghost, ghost.dir);
        ghost.x = newPos.x;
        ghost.y = newPos.y;
      });
    }

    function checkCollisions() {
      ghosts.forEach(ghost => {
        if (ghost.x === pacman.x && ghost.y === pacman.y) {
          if (scared) {
            score += 200;
            document.getElementById('score').textContent = 'Score: ' + score;
            ghost.x = 14;
            ghost.y = 14;
          } else {
            endGame(false);
          }
        }
      });

      if (dots.length === 0) {
        endGame(true);
      }
    }

    function endGame(won) {
      gameOver = true;
      document.getElementById('gameOverText').textContent = won ? '¡GANASTE!' : 'GAME OVER';
      document.getElementById('finalScore').textContent = 'Score Final: ' + score;
      document.getElementById('gameOver').style.display = 'block';
    }

    function resetGame() {
      resizeCanvas();
      pacman = { x: 14, y: 23, dir: 'right', nextDir: 'right' };
      ghosts = [
        { x: 12, y: 14, color: '#FF0000', dir: 'up' },
        { x: 14, y: 14, color: '#FFB8FF', dir: 'down' },
        { x: 15, y: 14, color: '#00FFFF', dir: 'left' },
        { x: 16, y: 14, color: '#FFB852', dir: 'right' }
      ];
      initDots();
      score = 0;
      gameOver = false;
      scared = false;
      scaredTimer = 0;
      document.getElementById('score').textContent = 'Score: 0';
      document.getElementById('gameOver').style.display = 'none';
      gameLoop();
    }

    function gameLoop() {
      if (gameOver) return;

      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      drawMaze();
      drawDots();
      drawGhosts();
      drawPacman();

      animationFrame++;
      if (animationFrame % 10 === 0) {
        mouthOpen = !mouthOpen;
        updatePacman();
        updateGhosts();
        checkCollisions();

        if (scared) {
          scaredTimer -= 100;
          if (scaredTimer <= 0) {
            scared = false;
          }
        }
      }

      requestAnimationFrame(gameLoop);
    }

    document.addEventListener('keydown', (e) => {
      if (gameOver) return;
      if (e.key === 'ArrowUp') pacman.nextDir = 'up';
      if (e.key === 'ArrowDown') pacman.nextDir = 'down';
      if (e.key === 'ArrowLeft') pacman.nextDir = 'left';
      if (e.key === 'ArrowRight') pacman.nextDir = 'right';
    });

    document.getElementById('restartBtn').addEventListener('click', resetGame);

    initDots();
    gameLoop();
  </script>
</body>
</html>
