<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pac-Man Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #000;
            font-family: Arial, sans-serif;
            color: white;
            /* CRUCIAL: Evita que el navegador haga scroll al tocar */
            touch-action: none; 
        }

        #score {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 20px;
        }

        #gameCanvas {
            border: 4px solid #1e40af;
            background-color: #000;
        }
    /* ‚úÖ Estilo responsive para m√≥viles */
    #gameCanvas {
      width: 100%;
      height: auto;
      max-width: 560px;
    }

        #controls {
            margin-top: 20px;
            text-align: center;
        }

        #gameOver {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 10px;
            text-align: center;
            z-index: 10; /* Asegura que se vea por encima del canvas */
        }

        #gameOver h2 {
            color: #FFD700;
            font-size: 48px;
            margin-bottom: 20px;
        }

        #gameOver p {
            font-size: 24px;
            margin-bottom: 20px;
        }

        #restartBtn {
            padding: 15px 30px;
            font-size: 18px;
            background-color: #FFD700;
            color: #000;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
        }

        #restartBtn:hover {
            background-color: #FFC700;
        }

        .info {
            font-size: 14px;
            color: #999;
            margin-top: 10px;
        }
        /* Estilo para mostrar una gu√≠a de joystick virtual (opcional) */
        #touchGuide {
            color: #FFD700;
            font-size: 14px;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div id="score">Score: 0</div>
    <canvas id="gameCanvas" width="560" height="620"></canvas>
    <div id="controls">
        <p>Mueve el dedo sobre la pantalla para dirigir a Pac-Man.</p>
        <p class="info">Usa las flechas del teclado en PC.</p>
        <p class="info">Come todos los puntos y evita los fantasmas</p>
    </div>

    <div id="gameOver">
        <h2 id="gameOverText">GAME OVER</h2>
        <p id="finalScore">Score Final: 0</p>
        <button id="restartBtn">Jugar de Nuevo</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const CELL_SIZE = 20;
        const GRID_WIDTH = 28;
        const GRID_HEIGHT = 31;
        
        // --- Variables T√ÅCTILES ---
        let touchStartX = 0;
        let touchStartY = 0;
        const SWIPE_THRESHOLD = 30; // Distancia m√≠nima para detectar un movimiento
        // -------------------------

        const MAZE = [
            // ... (Laberinto completo para mantener el archivo conciso, asume que est√° aqu√≠)
            "############################",
            "#............##............#",
            "#.####.#####.##.#####.####.#",
            "#o####.#####.##.#####.####o#",
            "#.####.#####.##.#####.####.#",
            "#..........................#",
            "#.####.##.########.##.####.#",
            "#.####.##.########.##.####.#",
            "#......##....##....##......#",
            "######.##### ## #####.######",
            "######.##### ## #####.######",
            "######.##          ##.######",
            "######.## ###--### ##.######",
            "######.## #        # ##.######",
            "       .   #        #   .      ",
            "######.## #        # ##.######",
            "######.## ######## ##.######",
            "######.##          ##.######",
            "######.## ######## ##.######",
            "######.## ######## ##.######",
            "#............##............#",
            "#.####.#####.##.#####.####.#",
            "#.####.#####.##.#####.####.#",
            "#o..##................##..o#",
            "###.##.##.########.##.##.###",
            "###.##.##.########.##.##.###",
            "#......##....##....##......#",
            "#.##########.##.##########.#",
            "#.##########.##.##########.#",
            "#..........................#",
            "############################"
        ];

        let pacman = { x: 14, y: 23, dir: 'right', nextDir: 'right' };
        let ghosts = [
            { x: 12, y: 14, color: '#FF0000', dir: 'up' },
            { x: 14, y: 14, color: '#FFB8FF', dir: 'down' },
            { x: 15, y: 14, color: '#00FFFF', dir: 'left' },
            { x: 16, y: 14, color: '#FFB852', dir: 'right' }
        ];
        let dots = [];
        let score = 0;
        let gameOver = false;
        let scared = false;
        let scaredTimer = 0;
        let mouthOpen = true;
        let animationFrame = 0;

        function initDots() {
            dots = [];
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const cell = MAZE[y][x];
                    if (cell === '.') dots.push({ x, y, type: 'dot' });
                    if (cell === 'o') dots.push({ x, y, type: 'power' });
                }
            }
        }

        function isWall(x, y) {
            if (y < 0 || y >= GRID_HEIGHT || x < 0 || x >= GRID_WIDTH) return true;
            return MAZE[y][x] === '#';
        }

        function canMove(x, y, dir) {
            let newX = x, newY = y;
            if (dir === 'up') newY--;
            if (dir === 'down') newY++;
            if (dir === 'left') newX--;
            if (dir === 'right') newX++;
            
            if (newX < 0) newX = GRID_WIDTH - 1;
            if (newX >= GRID_WIDTH) newX = 0;
            
            return !isWall(newX, newY);
        }

        function moveEntity(entity, dir) {
            let { x, y } = entity;
            if (dir === 'up') y--;
            if (dir === 'down') y++;
            if (dir === 'left') x--;
            if (dir === 'right') x++;
            
            if (x < 0) x = GRID_WIDTH - 1;
            if (x >= GRID_WIDTH) x = 0;
            
            return { x, y };
        }

        function drawMaze() {
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    if (MAZE[y][x] === '#') {
                        ctx.fillStyle = '#1e3a8a';
                        ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    }
                }
            }
        }

        function drawDots() {
            dots.forEach(dot => {
                ctx.fillStyle = '#FFB897';
                if (dot.type === 'power') {
                    ctx.beginPath();
                    ctx.arc(dot.x * CELL_SIZE + 10, dot.y * CELL_SIZE + 10, 5, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    ctx.arc(dot.x * CELL_SIZE + 10, dot.y * CELL_SIZE + 10, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }

        function drawPacman() {
            ctx.save();
            ctx.translate(pacman.x * CELL_SIZE + 10, pacman.y * CELL_SIZE + 10);
            
            let rotation = 0;
            if (pacman.dir === 'up') rotation = -Math.PI / 2;
            if (pacman.dir === 'down') rotation = Math.PI / 2;
            if (pacman.dir === 'left') rotation = Math.PI;
            ctx.rotate(rotation);

            ctx.fillStyle = '#FFFF00';
            ctx.beginPath();
            
            if (mouthOpen) {
                ctx.arc(0, 0, 10, 0.2 * Math.PI, 1.8 * Math.PI);
                ctx.lineTo(0, 0);
            } else {
                ctx.arc(0, 0, 10, 0, Math.PI * 2);
            }
            
            ctx.fill();
            ctx.restore();
        }

        function drawGhosts() {
            ghosts.forEach(ghost => {
                ctx.fillStyle = scared ? '#0000FF' : ghost.color;
                
                // Cuerpo
                ctx.beginPath();
                ctx.arc(ghost.x * CELL_SIZE + 10, ghost.y * CELL_SIZE + 8, 8, Math.PI, 0, false);
                ctx.lineTo(ghost.x * CELL_SIZE + 18, ghost.y * CELL_SIZE + 18);
                ctx.lineTo(ghost.x * CELL_SIZE + 15, ghost.y * CELL_SIZE + 15);
                ctx.lineTo(ghost.x * CELL_SIZE + 12, ghost.y * CELL_SIZE + 18);
                ctx.lineTo(ghost.x * CELL_SIZE + 9, ghost.y * CELL_SIZE + 15);
                ctx.lineTo(ghost.x * CELL_SIZE + 6, ghost.y * CELL_SIZE + 18);
                ctx.lineTo(ghost.x * CELL_SIZE + 3, ghost.y * CELL_SIZE + 15);
                ctx.lineTo(ghost.x * CELL_SIZE + 2, ghost.y * CELL_SIZE + 18);
                ctx.closePath();
                ctx.fill();

                // Ojos
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(ghost.x * CELL_SIZE + 7, ghost.y * CELL_SIZE + 8, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(ghost.x * CELL_SIZE + 13, ghost.y * CELL_SIZE + 8, 2, 0, Math.PI * 2);
                ctx.fill();

                if (!scared) {
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(ghost.x * CELL_SIZE + 7, ghost.y * CELL_SIZE + 8, 1, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(ghost.x * CELL_SIZE + 13, ghost.y * CELL_SIZE + 8, 1, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }

        function updatePacman() {
            // L√≥gica de movimiento
            if (canMove(pacman.x, pacman.y, pacman.nextDir)) {
                pacman.dir = pacman.nextDir;
            }
            
            if (canMove(pacman.x, pacman.y, pacman.dir)) {
                const newPos = moveEntity(pacman, pacman.dir);
                pacman.x = newPos.x;
                pacman.y = newPos.y;
            }

            // Comer puntos
            for (let i = dots.length - 1; i >= 0; i--) {
                if (dots[i].x === pacman.x && dots[i].y === pacman.y) {
                    if (dots[i].type === 'power') {
                        score += 50;
                        scared = true;
                        scaredTimer = 6000;
                    } else {
                        score += 10;
                    }
                    dots.splice(i, 1);
                    document.getElementById('score').textContent = 'Score: ' + score;
                }
            }
        }

        function updateGhosts() {
            ghosts.forEach(ghost => {
                const possibleDirs = ['up', 'down', 'left', 'right'].filter(d => 
                    canMove(ghost.x, ghost.y, d)
                );
                
                if (possibleDirs.length === 0) return;
                
                if (!canMove(ghost.x, ghost.y, ghost.dir) || Math.random() < 0.1) {
                    ghost.dir = possibleDirs[Math.floor(Math.random() * possibleDirs.length)];
                }
                
                const newPos = moveEntity(ghost, ghost.dir);
                ghost.x = newPos.x;
                ghost.y = newPos.y;
            });
        }

        function checkCollisions() {
            ghosts.forEach(ghost => {
                if (ghost.x === pacman.x && ghost.y === pacman.y) {
                    if (scared) {
                        score += 200;
                        document.getElementById('score').textContent = 'Score: ' + score;
                        // Reiniciar fantasma a su posici√≥n inicial
                        ghost.x = 14;
                        ghost.y = 14;
                    } else {
                        endGame(false);
                    }
                }
            });

            if (dots.length === 0) {
                endGame(true);
            }
        }

        function endGame(won) {
            gameOver = true;
            document.getElementById('gameOverText').textContent = won ? '¬°GANASTE!' : 'GAME OVER';
            document.getElementById('finalScore').textContent = 'Score Final: ' + score;
            document.getElementById('gameOver').style.display = 'block';
        }

        function resetGame() {
            pacman = { x: 14, y: 23, dir: 'right', nextDir: 'right' };
            ghosts = [
                { x: 12, y: 14, color: '#FF0000', dir: 'up' },
                { x: 14, y: 14, color: '#FFB8FF', dir: 'down' },
                { x: 15, y: 14, color: '#00FFFF', dir: 'left' },
                { x: 16, y: 14, color: '#FFB852', dir: 'right' }
            ];
            initDots();
            score = 0;
            gameOver = false;
            scared = false;
            scaredTimer = 0;
            animationFrame = 0;
            document.getElementById('score').textContent = 'Score: 0';
            document.getElementById('gameOver').style.display = 'none';
            gameLoop();
        }

        // üö® FUNCI√ìN CRUCIAL: Limpieza y Bucle del Juego
        function gameLoop() {
            if (gameOver) return;

            // ‚úÖ SOLUCI√ìN AL EFECTO FANTASMA: Borrado r√°pido del canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height); 
            
            drawMaze();
            drawDots();
            drawGhosts();
            drawPacman();

            animationFrame++;
            if (animationFrame % 10 === 0) {
                mouthOpen = !mouthOpen;
                updatePacman();
                updateGhosts();
                checkCollisions();

                if (scared) {
                    scaredTimer -= 100;
                    if (scaredTimer <= 0) {
                        scared = false;
                    }
                }
            }

            requestAnimationFrame(gameLoop);
        }

        // =======================================================
        // üïπÔ∏è L√ìGICA DEL JOYSTICK T√ÅCTIL (M√âTODO SWIPE)
        // =======================================================

        canvas.addEventListener('touchstart', (e) => {
            if (gameOver) return;
            e.preventDefault();
            // Guarda la posici√≥n inicial del toque
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        });

        canvas.addEventListener('touchend', (e) => {
            if (gameOver) return;
            e.preventDefault();
            
            // Obtener la posici√≥n final al levantar el dedo
            // Nota: touchend no tiene touches[], usamos la posici√≥n de touchend
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;

            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;

            // Determinar si el movimiento fue horizontal o vertical
            if (Math.abs(deltaX) > SWIPE_THRESHOLD || Math.abs(deltaY) > SWIPE_THRESHOLD) {
                if (Math.abs(deltaX) > Math.abs(deltaY)) {
                    // Movimiento horizontal (Izquierda/Derecha)
                    if (deltaX > 0) pacman.nextDir = 'right';
                    else pacman.nextDir = 'left';
                } else {
                    // Movimiento vertical (Arriba/Abajo)
                    if (deltaY > 0) pacman.nextDir = 'down';
                    else pacman.nextDir = 'up';
                }
            }
        });

        // Controles de Teclado (para PC)
        document.addEventListener('keydown', (e) => {
            if (gameOver) return;
            if (e.key === 'ArrowUp') pacman.nextDir = 'up';
            if (e.key === 'ArrowDown') pacman.nextDir = 'down';
            if (e.key === 'ArrowLeft') pacman.nextDir = 'left';
            if (e.key === 'ArrowRight') pacman.nextDir = 'right';
        });

        document.getElementById('restartBtn').addEventListener('click', resetGame);

        initDots();
        gameLoop();
    </script>
</body>
</html>

