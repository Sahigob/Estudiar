<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pac-Man Modificado</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #333;
            font-family: sans-serif;
            color: white;
            margin: 0;
            padding: 0;
        }

        /* 游눤 C칍DIGO MODIFICADO: Ajuste de Ancho para M칩viles */
        #gameCanvas {
            border: 4px solid #1e40af;
            background-color: #000;
            /* Usa el 95% del ancho del viewport para mejor adaptaci칩n en m칩vil */
            width: 95vw; 
            height: auto; 
            /* L칤mite para pantallas de escritorio */
            max-width: 560px; 
            display: block;
            margin: 20px auto;
        }

        #score {
            margin-bottom: 10px;
            font-size: 1.5em;
        }
    </style>
</head>
<body>

    <div id="score">Score: 0</div>
    <canvas id="gameCanvas"></canvas>

    <script>
        // === 1. CONFIGURACI칍N DEL JUEGO ===
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Mapa cl치sico de Pac-Man (solo estructura, 28x31)
        const map = [
            "############################",
            "#............##............#",
            "#.####.####.###.####.####.#",
            "#*####.####.###.####.####*#",
            "#.####.####.###.####.####.#",
            "#..........................#",
            "#.####.##.########.##.####.#",
            "#.####.##.########.##.####.#",
            "#......##....##....##......#",
            "######.####.##.##.####.#####",
            "     #.####.##.##.####.#    ",
            "     #.##.        .##.#    ",
            "     #.##.######.##.#    ",
            "#####.##.######.##.#####",
            "      .  .      .      .  ", // <-- Fila del t칰nel: celdas vac칤as ('.') a los lados del centro
            "#####.##.######.##.#####",
            "     #.##.######.##.#    ",
            "     #.##.  .   .##.#    ",
            "     #.##.####.##.#    ",
            "############################"
        ];
        
        const GRID_HEIGHT = map.length;
        const GRID_WIDTH = map[0].length;
        
        // 游눤 C칍DIGO MODIFICADO: 'let' para redefinir el tama침o de la celda en el resize
        let CELL_SIZE; 
        
        // Colores y propiedades
        const WALL_COLOR = '#1e40af';
        const PACMAN_COLOR = 'yellow';
        const DOT_COLOR = 'white';
        
        let score = 0;
        let scared = false;
        let scaredTimer = 0;
        let gameLoopInterval;

        // Pacman
        let pacman = {
            x: 1, // Columna inicial
            y: 1, // Fila inicial
            dir: 'right', // Direcci칩n actual
            nextDir: 'right' // Pr칩xima direcci칩n deseada
        };

        // Puntos
        let dots = [];
        
        // === 2. FUNCIONES DE DIBUJO Y L칍GICA B츼SICA ===

        // Inicia el juego y distribuye los puntos
        function initGame() {
            // Generar puntos normales ('.') y puntos de poder ('*')
            dots = [];
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    if (map[y][x] === '.') {
                        dots.push({ x: x, y: y, type: 'dot' });
                    } else if (map[y][x] === '*') {
                        dots.push({ x: x, y: y, type: 'power' });
                    }
                }
            }
        }
        
        // FUNCIONES AUXILIARES
        function isWall(x, y) {
            if (y < 0 || y >= GRID_HEIGHT || x < 0 || x >= GRID_WIDTH) {
                return false; // El t칰nel no se considera muro
            }
            return map[y][x] === '#';
        }

        function canMove(x, y, dir) {
            let nextX = x;
            let nextY = y;
            if (dir === 'up') nextY--;
            if (dir === 'down') nextY++;
            if (dir === 'left') nextX--;
            if (dir === 'right') nextX++;

            // Permite movimiento si es t칰nel o si no es muro
            return !isWall(nextX, nextY); 
        }

        function draw() {
            // Limpia el canvas
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Dibuja el laberinto y los puntos
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const cell = map[y][x];
                    if (cell === '#') {
                        ctx.fillStyle = WALL_COLOR;
                        ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    }
                }
            }
            
            // Dibuja los puntos
            dots.forEach(dot => {
                ctx.fillStyle = DOT_COLOR;
                if (dot.type === 'power') {
                    // Puntos de poder m치s grandes
                    ctx.beginPath();
                    ctx.arc(dot.x * CELL_SIZE + CELL_SIZE / 2, dot.y * CELL_SIZE + CELL_SIZE / 2, CELL_SIZE / 4, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Puntos normales
                    ctx.beginPath();
                    ctx.arc(dot.x * CELL_SIZE + CELL_SIZE / 2, dot.y * CELL_SIZE + CELL_SIZE / 2, CELL_SIZE / 8, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // Dibuja a Pac-Man
            ctx.fillStyle = PACMAN_COLOR;
            ctx.beginPath();
            ctx.arc(pacman.x * CELL_SIZE + CELL_SIZE / 2, pacman.y * CELL_SIZE + CELL_SIZE / 2, CELL_SIZE / 3, 0, Math.PI * 2);
            ctx.fill();
        }

        // === 3. FUNCI칍N DE ACTUALIZACI칍N (MODIFICADA) ===

        /* 游뚿 C칍DIGO MODIFICADO: Implementaci칩n del T칰nel Lateral (Teletransporte) */
        function updatePacman() {
            // Intenta cambiar de direcci칩n si es posible
            if (canMove(pacman.x, pacman.y, pacman.nextDir)) {
                pacman.dir = pacman.nextDir;
            }
            
            // Calcula la posici칩n futura (pero no la aplica todav칤a)
            let newX = pacman.x;
            let newY = pacman.y;

            if (pacman.dir === 'up') newY--;
            if (pacman.dir === 'down') newY++;
            if (pacman.dir === 'left') newX--;
            if (pacman.dir === 'right') newX++;
            
            // 游뚿 L칍GICA DEL T칔NEL (TELETRANSPORTE)
            if (newX < 0) {
                // Si va m치s all치 de la izquierda (columna -1), aparece en el lado derecho
                newX = GRID_WIDTH - 1; 
            } else if (newX >= GRID_WIDTH) {
                // Si va m치s all치 de la derecha (columna 28), aparece en el lado izquierdo
                newX = 0;
            }

            // Comprueba si el movimiento es v치lido (ya sea una celda vac칤a o la teletransportaci칩n)
            if (!isWall(newX, newY)) {
                pacman.x = newX;
                pacman.y = newY;
            }

            // L칩gica de comer puntos (NO MODIFICADA)
            for (let i = dots.length - 1; i >= 0; i--) {
                if (dots[i].x === pacman.x && dots[i].y === pacman.y) {
                    if (dots[i].type === 'power') {
                        score += 50;
                        scared = true;
                        scaredTimer = 6000;
                    } else {
                        score += 10;
                    }
                    dots.splice(i, 1);
                    document.getElementById('score').textContent = 'Score: ' + score;
                }
            }
        }

        // === 4. BUCLE PRINCIPAL Y MANEJO DE ENTRADA ===

        function gameLoop() {
            updatePacman();
            // L칩gica de fantasmas (omito la complejidad aqu칤, pero la funci칩n updatePacman es la que se modifica)
            draw();
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowUp') pacman.nextDir = 'up';
            else if (e.key === 'ArrowDown') pacman.nextDir = 'down';
            else if (e.key === 'ArrowLeft') pacman.nextDir = 'left';
            else if (e.key === 'ArrowRight') pacman.nextDir = 'right';
        });

        // === 5. AJUSTE DE TAMA칌O Y COMIENZO DEL JUEGO ===

        /* 游눤 C칍DIGO MODIFICADO: L칩gica de adaptaci칩n del Canvas (Responsividad) */
        const aspectRatio = GRID_HEIGHT / GRID_WIDTH; // 31/28

        function adjustCanvasSize() {
            // canvas.clientWidth obtiene el tama침o establecido por el CSS (95vw)
            const displayWidth = canvas.clientWidth; 
            canvas.width = displayWidth;
            canvas.height = displayWidth * aspectRatio;
            
            // Recalcula el tama침o de la celda en funci칩n del nuevo ancho
            CELL_SIZE = canvas.width / GRID_WIDTH; 
            draw(); // Redibuja con el nuevo tama침o
        }

        // Llama al ajuste al inicio
        adjustCanvasSize();
        
        // Escucha el evento de redimensionamiento (al girar el m칩vil o cambiar la ventana)
        window.addEventListener('resize', adjustCanvasSize);

        // Iniciar el juego
        initGame();
        // El bucle principal del juego se ejecuta aproximadamente 10 veces por segundo
        gameLoopInterval = setInterval(gameLoop, 100); 

    </script>
</body>
</html>
