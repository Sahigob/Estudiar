<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Pong 1 Jugador</title>
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }
  html, body {
    height: 100%;
    background: #000;
    display: flex;
    justify-content: center;
    align-items: center;
    font-family: Arial, sans-serif;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
  }
  #scoreboard {
    position: absolute;
    top: 10px;
    width: 100%;
    max-width: 600px;
    color: #0ff;
    font-size: 20px;
    display: flex;
    justify-content: space-between;
    padding: 0 20px;
    z-index: 10;
  }
  #pongCanvas {
    background: #000;
    border: 3px solid #0ff;
    border-radius: 10px;
    touch-action: none;
    width: 90vw;
    max-width: 600px;
    aspect-ratio: 3 / 2;
    display: block;
  }
</style>
</head>
<body>

<div id="scoreboard">
  <div>Máquina: <span id="scoreTop">0</span></div>
  <div>Jugador: <span id="scoreBottom">0</span></div>
</div>

<canvas id="pongCanvas" width="600" height="400"></canvas>

<script>
(() => {
  const canvas = document.getElementById('pongCanvas');
  const ctx = canvas.getContext('2d');
  const scoreTopElem = document.getElementById('scoreTop');
  const scoreBottomElem = document.getElementById('scoreBottom');

  const WIDTH = canvas.width;
  const HEIGHT = canvas.height;

  const PADDLE_WIDTH = 120;
  const PADDLE_HEIGHT = 15;
  const BALL_RADIUS = 8;

  const WIN_SCORE = 10;

  let paddleTopX = (WIDTH - PADDLE_WIDTH) / 2;
  let paddleBottomX = (WIDTH - PADDLE_WIDTH) / 2;

  let ballX = WIDTH / 2;
  let ballY = HEIGHT / 2;
  let ballSpeedX = 3 * (Math.random() < 0.5 ? -1 : 1);
  let ballSpeedY = 5 * (Math.random() < 0.5 ? -1 : 1);

  let scoreTop = 0;
  let scoreBottom = 0;

  let gameOver = false;

  const AI_SPEED = 4;

  // ------------------------------------------------------------------
  // FUNCIÓN CORREGIDA para llamar directamente a la función del padre
  // ------------------------------------------------------------------
  function notifyParent(playerWon) {
    // Parámetro playerWon es true si ganó el jugador, false si ganó la máquina.
    setTimeout(() => {
      try {
        if(window.parent && window.parent !== window && typeof window.parent.endGame === 'function'){
          // Llama a la función del padre (endGame) con el resultado booleano.
          window.parent.endGame(playerWon);
        } else {
          // Fallback de redirección si no puede acceder al padre
          window.location.href = '/'; 
        }
      } catch(e) {
        // Fallback de redirección si la Política de Mismo Origen lo bloquea
        window.location.href = '/';
      }
    }, 2500);
  }
  // ------------------------------------------------------------------


  function fixDPI() {
    const dpi = window.devicePixelRatio || 1;
    if(canvas.width !== WIDTH * dpi || canvas.height !== HEIGHT * dpi){
      canvas.width = WIDTH * dpi;
      canvas.height = HEIGHT * dpi;
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.scale(dpi, dpi);
    }
  }
  fixDPI();

  function drawPaddle(x, y) {
    ctx.fillStyle = '#0ff';
    ctx.shadowColor = '#0ff';
    ctx.shadowBlur = 8;
    ctx.fillRect(x, y, PADDLE_WIDTH, PADDLE_HEIGHT);
    ctx.shadowBlur = 0;
  }

  function drawBall() {
    ctx.beginPath();
    ctx.fillStyle = '#0ff';
    ctx.shadowColor = '#0ff';
    ctx.shadowBlur = 15;
    ctx.arc(ballX, ballY, BALL_RADIUS, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }

  function draw() {
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    drawPaddle(paddleTopX, 0);
    drawPaddle(paddleBottomX, HEIGHT - PADDLE_HEIGHT);
    drawBall();
  }

  function limitSpeed() {
    const maxX = 9;
    if (ballSpeedX > maxX) ballSpeedX = maxX;
    if (ballSpeedX < -maxX) ballSpeedX = -maxX;
  }

  function updateBall() {
    if (gameOver) return;

    ballX += ballSpeedX;
    ballY += ballSpeedY;

    // Laterales
    if (ballX - BALL_RADIUS <= 0) {
      ballX = BALL_RADIUS;
      ballSpeedX *= -1;
    }
    if (ballX + BALL_RADIUS >= WIDTH) {
      ballX = WIDTH - BALL_RADIUS;
      ballSpeedX *= -1;
    }

    // Paleta IA (Superior)
    if (ballY - BALL_RADIUS <= PADDLE_HEIGHT) {
      if (ballX >= paddleTopX && ballX <= paddleTopX + PADDLE_WIDTH) {
        ballY = PADDLE_HEIGHT + BALL_RADIUS;
        ballSpeedY *= -1;

        let hitPos = ballX - (paddleTopX + PADDLE_WIDTH / 2);
        ballSpeedX = hitPos * 0.09;
        limitSpeed();
      } else {
        scoreBottom++;
        updateScores();
        checkWin();
        resetBall(true);
      }
    }

    // Paleta jugador (Inferior)
    if (ballY + BALL_RADIUS >= HEIGHT - PADDLE_HEIGHT) {
      if (ballX >= paddleBottomX && ballX <= paddleBottomX + PADDLE_WIDTH) {
        ballY = HEIGHT - PADDLE_HEIGHT - BALL_RADIUS;
        ballSpeedY *= -1;

        let hitPos = ballX - (paddleBottomX + PADDLE_WIDTH / 2);
        ballSpeedX = hitPos * 0.09;
        limitSpeed();
      } else {
        scoreTop++;
        updateScores();
        checkWin();
        resetBall(false);
      }
    }
  }

  function updateScores() {
    scoreTopElem.textContent = scoreTop;
    scoreBottomElem.textContent = scoreBottom;
  }

  // Función checkWin llama a notifyParent con el booleano
  function checkWin() {
    if (scoreTop >= WIN_SCORE || scoreBottom >= WIN_SCORE) {
      gameOver = true;
      ballSpeedX = 0;
      ballSpeedY = 0;
      
      const playerWon = scoreBottom >= WIN_SCORE;
      
      alert(playerWon ? "¡Ganas tú!" : "¡Gana la Máquina!");
      notifyParent(playerWon); // Envía true si gana jugador, false si gana máquina
    }
  }

  function resetBall(topStarts) {
    if (gameOver) return;

    ballX = WIDTH / 2;
    ballY = HEIGHT / 2;
    ballSpeedX = 5 * (Math.random() < 0.5 ? -1 : 1);
    ballSpeedY = topStarts ? 8 : -8;
  }

  function updateAI() {
    if (gameOver) return;

    let target = ballX - PADDLE_WIDTH / 2;
    if (paddleTopX < target) paddleTopX += AI_SPEED;
    if (paddleTopX > target) paddleTopX -= AI_SPEED;

    paddleTopX = Math.max(0, Math.min(WIDTH - PADDLE_WIDTH, paddleTopX));
  }

  canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    if (gameOver) return;
    const rect = canvas.getBoundingClientRect();
    const x = e.touches[0].clientX - rect.left;
    paddleBottomX = x - PADDLE_WIDTH / 2;
    paddleBottomX = Math.max(0, Math.min(WIDTH - PADDLE_WIDTH, paddleBottomX));
  }, { passive: false });

  canvas.addEventListener('mousemove', e => {
    if (gameOver) return;
    if(e.buttons !== 1) return;
    const rect = canvas.getBoundingClientRect();
    paddleBottomX = e.clientX - rect.left - PADDLE_WIDTH / 2;
    paddleBottomX = Math.max(0, Math.min(WIDTH - PADDLE_WIDTH, paddleBottomX));
  });

  function loop() {
    updateAI();
    updateBall();
    draw();
    requestAnimationFrame(loop);
  }

  loop();
})();
</script>

</body>
</html>
