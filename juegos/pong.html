<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Pong 1 Jugador</title>
<style>
/* --- ESTILOS GENERALES --- */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}
html, body {
    width: 100%;
    height: 100%; 
    overflow: hidden;
    background: #000;
    display: flex;
    justify-content: flex-start;
    align-items: center; 
    font-family: Arial, sans-serif;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
    flex-direction: column;
}

/* --- ESTILOS DE PUNTUACIÓN (BARRA SUPERIOR) --- */
#scoreboard {
    position: relative; 
    margin-top: 20px; 
    margin-bottom: 20px; 
    width: 90%; 
    color: #0ff;
    font-size: 20px;
    display: flex;
    justify-content: space-between;
    padding: 0 5%;
    z-index: 10;
}

/* --- ESTILOS DEL CANVAS DE JUEGO (MAXIMIZACIÓN Y CUADRADO) --- */
#pongCanvas {
    background: #000;
    border: 3px solid #0ff;
    border-radius: 10px;
    touch-action: none;
    
    width: 90vw; 
    aspect-ratio: 1 / 1;
    max-height: calc(100vh - 80px); 
    
    display: block;
    flex-grow: 1;
    margin-bottom: 20px; 
}
</style>
</head>
<body>

<div id="scoreboard">
    <div>Máquina: <span id="scoreTop">0</span></div>
    <div>Jugador: <span id="scoreBottom">0</span></div>
</div>

<canvas id="pongCanvas" width="600" height="600"></canvas>

<script>
(() => {
    const canvas = document.getElementById('pongCanvas');
    const ctx = canvas.getContext('2d');
    const scoreTopElem = document.getElementById('scoreTop');
    const scoreBottomElem = document.getElementById('scoreBottom');

    // Las dimensiones lógicas del juego (internas)
    const WIDTH = canvas.width;
    const HEIGHT = canvas.height;

    const PADDLE_WIDTH = 120;
    const PADDLE_HEIGHT = 15;
    const BALL_RADIUS = 8;
    
    const VERTICAL_OFFSET = 30; 

    const WIN_SCORE = 10;

    // ⭐ NUEVAS CONSTANTES PARA EL CONTROL DE VELOCIDAD
    const TARGET_SPEED_X = 7;
    const TARGET_SPEED_Y = 10;
    const ACCELERATION_RATE = 0.05; // Cuánto acelera la bola por fotograma

    let paddleTopX = (WIDTH - PADDLE_WIDTH) / 2;
    let paddleBottomX = (WIDTH - PADDLE_WIDTH) / 2;

    let ballX = WIDTH / 2;
    
    // ⭐ INICIO LENTO Y DESDE LA BARRA DEL JUGADOR
    const bottomPaddleY = HEIGHT - PADDLE_HEIGHT - VERTICAL_OFFSET;
    let ballY = bottomPaddleY - BALL_RADIUS; 
    
    let ballSpeedX = 1 * (Math.random() < 0.5 ? -1 : 1); // Velocidad X inicial muy lenta
    let ballSpeedY = -2; // Velocidad Y inicial muy lenta, moviéndose hacia arriba

    let scoreTop = 0;
    let scoreBottom = 0;

    let gameOver = false;

    // Velocidad de la IA
    const AI_SPEED = 4;

    function notifyParent(playerWon) {
        setTimeout(() => {
            try {
                if(window.parent && window.parent !== window && typeof window.parent.endGame === 'function'){
                    window.parent.endGame(playerWon);
                } else {
                    window.location.href = '/'; 
                }
            } catch(e) {
                window.location.href = '/';
            }
        }, 2500);
    }

    function fixDPI() {
        const dpi = window.devicePixelRatio || 1;
        if(canvas.width !== WIDTH * dpi || canvas.height !== HEIGHT * dpi){
            canvas.width = WIDTH * dpi;
            canvas.height = HEIGHT * dpi;
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.scale(dpi, dpi);
        }
    }
    fixDPI();

    function drawPaddle(x, y) {
        ctx.fillStyle = '#0ff';
        ctx.shadowColor = '#0ff';
        ctx.shadowBlur = 8;
        ctx.fillRect(x, y, PADDLE_WIDTH, PADDLE_HEIGHT);
        ctx.shadowBlur = 0;
    }

    function drawBall() {
        ctx.beginPath();
        ctx.fillStyle = '#0ff';
        ctx.shadowColor = '#0ff';
        ctx.shadowBlur = 15;
        ctx.arc(ballX, ballY, BALL_RADIUS, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
    }

    function draw() {
        ctx.clearRect(0, 0, WIDTH, HEIGHT);
        // Dibujar líneas de límite (opcional)
        ctx.strokeStyle = 'rgba(0, 255, 255, 0.2)';
        ctx.lineWidth = 1;
        // Línea superior
        ctx.beginPath();
        ctx.moveTo(0, VERTICAL_OFFSET);
        ctx.lineTo(WIDTH, VERTICAL_OFFSET);
        ctx.stroke();
        // Línea inferior
        ctx.beginPath();
        ctx.moveTo(0, HEIGHT - VERTICAL_OFFSET);
        ctx.lineTo(WIDTH, HEIGHT - VERTICAL_OFFSET);
        ctx.stroke();
        
        // Coordenada Y de paleta superior ajustada
        drawPaddle(paddleTopX, VERTICAL_OFFSET); 
        // Coordenada Y de paleta inferior ajustada
        drawPaddle(paddleBottomX, HEIGHT - PADDLE_HEIGHT - VERTICAL_OFFSET);
        drawBall();
    }

    function limitSpeed() {
        const maxX = 9;
        if (ballSpeedX > maxX) ballSpeedX = maxX;
        if (ballSpeedX < -maxX) ballSpeedX = -maxX;
    }

    function updateBall() {
        if (gameOver) return;

        // ⭐ LÓGICA DE ACELERACIÓN GRADUAL
        // Aumenta la velocidad X hasta TARGET_SPEED_X
        if (Math.abs(ballSpeedX) < TARGET_SPEED_X) {
            ballSpeedX += Math.sign(ballSpeedX) * ACCELERATION_RATE;
        }
        // Aumenta la velocidad Y hasta TARGET_SPEED_Y
        if (Math.abs(ballSpeedY) < TARGET_SPEED_Y) {
            ballSpeedY += Math.sign(ballSpeedY) * ACCELERATION_RATE;
        }

        ballX += ballSpeedX;
        ballY += ballSpeedY;

        // Laterales
        if (ballX - BALL_RADIUS <= 0) {
            ballX = BALL_RADIUS;
            ballSpeedX *= -1;
        }
        if (ballX + BALL_RADIUS >= WIDTH) {
            ballX = WIDTH - BALL_RADIUS;
            ballSpeedX *= -1;
        }

        // Paleta IA (Superior)
        const topPaddleY = VERTICAL_OFFSET;
        if (ballY - BALL_RADIUS <= topPaddleY + PADDLE_HEIGHT) {
            if (ballX >= paddleTopX && ballX <= paddleTopX + PADDLE_WIDTH) {
                ballY = topPaddleY + PADDLE_HEIGHT + BALL_RADIUS;
                ballSpeedY *= -1;

                let hitPos = ballX - (paddleTopX + PADDLE_WIDTH / 2);
                ballSpeedX = hitPos * 0.09;
                limitSpeed();
            } else if (ballY - BALL_RADIUS <= topPaddleY) {
                // Punto de puntuación de la máquina (la bola cruza el límite superior)
                scoreBottom++;
                updateScores();
                checkWin();
                resetBall(true); // Machine starts next
            }
        }

        // Paleta jugador (Inferior)
        const currentBottomPaddleY = HEIGHT - PADDLE_HEIGHT - VERTICAL_OFFSET;
        if (ballY + BALL_RADIUS >= currentBottomPaddleY) {
            if (ballX >= paddleBottomX && ballX <= paddleBottomX + PADDLE_WIDTH) {
                ballY = currentBottomPaddleY - BALL_RADIUS;
                ballSpeedY *= -1;

                let hitPos = ballX - (paddleBottomX + PADDLE_WIDTH / 2);
                ballSpeedX = hitPos * 0.09;
                limitSpeed();
            } else if (ballY + BALL_RADIUS >= HEIGHT - VERTICAL_OFFSET) {
                // Punto de puntuación del jugador (la bola cruza el límite inferior)
                scoreTop++;
                updateScores();
                checkWin();
                resetBall(false); // Player starts next
            }
        }
    }

    function updateScores() {
        scoreTopElem.textContent = scoreTop;
        scoreBottomElem.textContent = scoreBottom;
    }

    function checkWin() {
        if (scoreTop >= WIN_SCORE || scoreBottom >= WIN_SCORE) {
            gameOver = true;
            ballSpeedX = 0;
            ballSpeedY = 0;
            
            const playerWon = scoreBottom >= WIN_SCORE;
            
            alert(playerWon ? "¡Ganas tú!" : "¡Gana la Máquina!");
            notifyParent(playerWon);
        }
    }

    function resetBall(topStarts) {
        if (gameOver) return;

        ballX = WIDTH / 2;
        
        // ⭐ POSICIÓN DE SERVICIO DINÁMICA (EN LA BARRA CORRESPONDIENTE)
        if (topStarts) {
            // El servicio va para la Máquina (sale de la paleta superior)
            const topPaddleY = VERTICAL_OFFSET;
            ballY = topPaddleY + PADDLE_HEIGHT + BALL_RADIUS;
            ballSpeedY = TARGET_SPEED_Y; // Velocidad rápida hacia abajo
        } else {
            // El servicio va para el Jugador (sale de la paleta inferior)
            const bottomPaddleY = HEIGHT - PADDLE_HEIGHT - VERTICAL_OFFSET;
            ballY = bottomPaddleY - BALL_RADIUS;
            ballSpeedY = -TARGET_SPEED_Y; // Velocidad rápida hacia arriba
        }

        // ⭐ VELOCIDADES DE REINICIO RÁPIDAS
        ballSpeedX = TARGET_SPEED_X * (Math.random() < 0.5 ? -1 : 1);
    }

    function updateAI() {
        if (gameOver) return;

        let target = ballX - PADDLE_WIDTH / 2;
        if (paddleTopX < target) paddleTopX += AI_SPEED;
        if (paddleTopX > target) paddleTopX -= AI_SPEED;

        paddleTopX = Math.max(0, Math.min(WIDTH - PADDLE_WIDTH, paddleTopX));
    }

    canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        if (gameOver) return;

        const rect = canvas.getBoundingClientRect();
        const xClient = e.touches[0].clientX;

        const xProportional = (xClient - rect.left) / rect.width;
        const xLogical = xProportional * WIDTH;

        paddleBottomX = xLogical - PADDLE_WIDTH / 2;
        paddleBottomX = Math.max(0, Math.min(WIDTH - PADDLE_WIDTH, paddleBottomX));
    }, { passive: false });

    canvas.addEventListener('mousemove', e => {
        if (gameOver) return;
        if(e.buttons !== 1) return;
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;

        const xProportional = x / rect.width;
        const xLogical = xProportional * WIDTH;

        paddleBottomX = xLogical - PADDLE_WIDTH / 2;
        paddleBottomX = Math.max(0, Math.min(WIDTH - PADDLE_WIDTH, paddleBottomX));
    });

    function loop() {
        updateAI();
        updateBall();
        draw();
        requestAnimationFrame(loop);
    }

    loop();
})();
</script>

</body>
</html>
