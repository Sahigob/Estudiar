<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Conecta 4 Educativo</title>
<style>
  body {
    margin: 0; padding: 10px;
    font-family: Arial, sans-serif;
    background: #111;
    color: #eee;
    display: flex;
    flex-direction: column;
    align-items: center;
    user-select: none;
  }
  #controls {
    margin-bottom: 15px;
  }
  button {
    background: #0a74da;
    color: #fff;
    border: none;
    border-radius: 6px;
    padding: 10px 20px;
    margin: 0 8px;
    cursor: pointer;
    font-size: 1rem;
    user-select: none;
  }
  button:disabled {
    background: #555;
    cursor: default;
  }
  #message {
    margin: 15px 0;
    font-size: 1.2rem;
    min-height: 1.6em;
    text-align: center;
  }
  canvas {
    background-color: #0052cc;
    border-radius: 12px;
    box-shadow: 0 0 10px #003d99;
    touch-action: manipulation;
    max-width: 100vw;
    height: auto;
  }
</style>
</head>
<body>

<h1>Conecta 4 Educativo</h1>

<div id="controls" role="group" aria-label="Modo de juego">
  <button id="btnPvP" aria-pressed="true">2 Jugadores</button>
  <button id="btnPvC" aria-pressed="false">Jugador vs MÃ¡quina</button>
</div>

<canvas id="gameCanvas" width="420" height="360" aria-label="Tablero de Conecta 4" role="img" tabindex="0"></canvas>

<div id="message" aria-live="polite"></div>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const messageElem = document.getElementById('message');
  const btnPvP = document.getElementById('btnPvP');
  const btnPvC = document.getElementById('btnPvC');

  // Board config
  const COLS = 7;
  const ROWS = 6;

  // Canvas dimensions and constants
  const CANVAS_WIDTH = canvas.width;
  const CANVAS_HEIGHT = canvas.height;
  const SLOT_SIZE = CANVAS_WIDTH / COLS;
  const RADIUS = SLOT_SIZE * 0.4;

  // Game state
  let board = [];
  let currentPlayer = 1; // 1=Red, 2=Yellow
  let vsComputer = false;
  let gameActive = true;

  // Initialize board: 0 = empty, 1 = player 1 disk, 2 = player 2 disk
  function initBoard() {
    board = [];
    for(let r=0; r<ROWS; r++) {
      const row = [];
      for(let c=0; c<COLS; c++) {
        row.push(0);
      }
      board.push(row);
    }
  }

  // Draw empty board and disks
  function drawBoard() {
    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    // Draw slots background
    ctx.fillStyle = '#0052cc';
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    // Draw slots and disks
    for(let r=0; r<ROWS; r++){
      for(let c=0; c<COLS; c++){
        const x = c * SLOT_SIZE + SLOT_SIZE/2;
        const y = (ROWS - 1 - r) * SLOT_SIZE + SLOT_SIZE/2;

        // Draw slot background: circle in blue
        ctx.beginPath();
        ctx.arc(x, y, RADIUS, 0, 2*Math.PI);
        ctx.fillStyle = '#003d99';
        ctx.fill();

        // Draw disk if any
        if(board[r][c] === 1) {
          ctx.fillStyle = '#ff0000'; // Red
        } else if(board[r][c] === 2) {
          ctx.fillStyle = '#ffff00'; // Yellow
        } else {
          ctx.fillStyle = '#1a1a66'; // Empty slot darker circle inside
          ctx.beginPath();
          ctx.arc(x, y, RADIUS * 0.8, 0, 2*Math.PI);
          ctx.fill();
          continue;
        }

        ctx.beginPath();
        ctx.arc(x, y, RADIUS * 0.85, 0, 2*Math.PI);
        ctx.fill();
      }
    }
  }

  // Get first empty row in a column, or -1 if full
  function getAvailableRow(col) {
    for(let r = 0; r < ROWS; r++){
      if(board[r][col] === 0){
        return r;
      }
    }
    return -1;
  }

  // Drop piece for player in column, return true if successful
  function dropPiece(col, player) {
    if(!gameActive) return false;
    const row = getAvailableRow(col);
    if(row === -1) return false;
    board[row][col] = player;
    return true;
  }

  // Check horizontal, vertical and diagonal for 4 in a row
  function checkWin(player) {
    // Horizontal
    for(let r=0; r<ROWS; r++){
      for(let c=0; c<=COLS-4; c++){
        if(board[r][c] === player &&
           board[r][c+1] === player &&
           board[r][c+2] === player &&
           board[r][c+3] === player) return true;
      }
    }
    // Vertical
    for(let c=0; c<COLS; c++){
      for(let r=0; r<=ROWS-4; r++){
        if(board[r][c] === player &&
           board[r+1][c] === player &&
           board[r+2][c] === player &&
           board[r+3][c] === player) return true;
      }
    }
    // Diagonal down-right
    for(let r=0; r<=ROWS-4; r++){
      for(let c=0; c<=COLS-4; c++){
        if(board[r][c] === player &&
           board[r+1][c+1] === player &&
           board[r+2][c+2] === player &&
           board[r+3][c+3] === player) return true;
      }
    }
    // Diagonal up-right
    for(let r=3; r<ROWS; r++){
      for(let c=0; c<=COLS-4; c++){
        if(board[r][c] === player &&
           board[r-1][c+1] === player &&
           board[r-2][c+2] === player &&
           board[r-3][c+3] === player) return true;
      }
    }
    return false;
  }

  // Check for draw (no empty slots)
  function checkDraw() {
    for(let c=0; c<COLS; c++){
      if(getAvailableRow(c) !== -1) return false;
    }
    return true;
  }

  // Show message in panel
  function showMessage(msg) {
    messageElem.textContent = msg;
  }

  // Update turn message
  function updateTurnMessage() {
    if(!gameActive) return;
    if(vsComputer) {
      showMessage(currentPlayer === 1 ? "Tu turno" : "Turno de la mÃ¡quina");
    } else {
      showMessage(`Turno jugador ${currentPlayer === 1 ? 'Rojo' : 'Amarillo'}`);
    }
  }

  // Switch player turn
  function switchTurn() {
    currentPlayer = 3 - currentPlayer;
    updateTurnMessage();
  }

  // Reset game state
  function resetGame() {
    initBoard();
    currentPlayer = 1;
    gameActive = true;
    showMessage('');
    updateTurnMessage();
    drawBoard();
  }

  // Simple AI to choose a column randomly from available (improved later as needed)
  function simpleAIPlay() {
    const validCols = [];
    for(let i=0; i<COLS; i++){
      if(getAvailableRow(i) !== -1) validCols.push(i);
    }
    if(validCols.length === 0) return -1;
    return validCols[Math.floor(Math.random() * validCols.length)];
  }

  // AI turn async to simulate delay
  async function aiTurn() {
    if(!gameActive || currentPlayer !== 2) return;
    showMessage('Turno de la mÃ¡quina...');
    await new Promise(resolve => setTimeout(resolve, 600)); // delay
    const col = simpleAIPlay();
    if(col === -1) return;
    dropPiece(col, 2);
    drawBoard();
    if(checkWin(2)) {
      gameActive = false;
      showMessage('La mÃ¡quina gana. Â¡Fin del juego!');
      notifyParent(false);
      return;
    }
    if(checkDraw()) {
      gameActive = false;
      showMessage('Empate. Â¡Fin del juego!');
      notifyParent(null);
      return;
    }
    switchTurn();
  }

  // Notify parent frame about game end, with fallback
  function notifyParent(playerWon) {
    // ParÃ¡metro true si ganÃ³ jugador, false si mÃ¡quina, null empate
    setTimeout(() => {
      try {
        if(window.parent && window.parent !== window && typeof window.parent.endGame === 'function'){
          window.parent.endGame(playerWon === true);
        } else {
          window.location.href = '/';
        }
      } catch(e) {
        window.location.href = '/';
      }
    }, 2500);
  }

  // Handle user clicking on board to place disk
  function handleClick(event) {
    if(!gameActive || currentPlayer !== 1) return;
    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const colClicked = Math.floor(x / SLOT_SIZE);
    if(colClicked < 0 || colClicked >= COLS) return;
    if(dropPiece(colClicked, 1)){
      drawBoard();
      if(checkWin(1)){
        gameActive = false;
        showMessage('Â¡Has ganado! ðŸŽ‰');
        notifyParent(true);
        return;
      }
      if(checkDraw()){
        gameActive = false;
        showMessage('Empate. Fin del juego.');
        notifyParent(null);
        return;
      }
      switchTurn();
      aiTurn();
    }
  }

  // Touch support: treat touch as click for simplicity
  canvas.addEventListener('touchstart', e => {
    if(e.touches.length === 1){
      handleClick(e.touches[0]);
    }
  });

  // Mouse support
  canvas.addEventListener('click', handleClick);

  // Buttons for mode selection
  btnPvP.addEventListener('click', () => {
    if(gameActive) return;
    vsComputer = false;
    btnPvP.setAttribute('aria-pressed', 'true');
    btnPvC.setAttribute('aria-pressed', 'false');
    showMessage('Modo 2 Jugadores activado');
    resetGame();
  });
  btnPvC.addEventListener('click', () => {
    if(gameActive) return;
    vsComputer = true;
    btnPvP.setAttribute('aria-pressed', 'false');
    btnPvC.setAttribute('aria-pressed', 'true');
    showMessage('Modo Jugador vs MÃ¡quina activado');
    resetGame();
  });

  // On load initialize PvP by default
  vsComputer = false;
  resetGame();

})();
</script>

</body>
</html>
