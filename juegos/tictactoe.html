<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Conecta 4 Educativo</title>
<style>
  body {
    margin: 0; padding: 10px;
    font-family: Arial, sans-serif;
    background: #111;
    color: #eee;
    display: flex;
    flex-direction: column;
    align-items: center;
    user-select: none;
  }
  #controls {
    margin-bottom: 15px;
  }
  button {
    background: #0a74da;
    color: #fff;
    border: none;
    border-radius: 6px;
    padding: 10px 20px;
    margin: 0 8px;
    cursor: pointer;
    font-size: 1rem;
    user-select: none;
  }
  button:disabled {
    background: #555;
    cursor: default;
  }
  #message {
    margin: 15px 0;
    font-size: 1.2rem;
    min-height: 1.6em;
    text-align: center;
  }
  canvas {
    background-color: #0052cc;
    border-radius: 12px;
    box-shadow: 0 0 10px #003d99;
    touch-action: manipulation;
    max-width: 100vw;
    height: auto;
  }
</style>
</head>
<body>

<h1>Conecta 4 Educativo</h1>

<div id="controls" role="group" aria-label="Modo de juego">
  <button id="btnPvP" aria-pressed="true">2 Jugadores</button>
  <button id="btnPvC" aria-pressed="false">Jugador vs M√°quina</button>
</div>

<canvas id="gameCanvas" width="420" height="360" aria-label="Tablero de Conecta 4" role="img" tabindex="0"></canvas>

<div id="message" aria-live="polite"></div>

<script>
(() => {
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const messageElem = document.getElementById('message');
    const btnPvP = document.getElementById('btnPvP');
    const btnPvC = document.getElementById('btnPvC');

    // Board config
    const COLS = 7;
    const ROWS = 6;

    // Canvas dimensions and constants
    const CANVAS_WIDTH = canvas.width;
    const CANVAS_HEIGHT = canvas.height;
    const SLOT_SIZE = CANVAS_WIDTH / COLS;
    const RADIUS = SLOT_SIZE * 0.4;

    // Game state
    let board = [];
    let currentPlayer = 1; // 1=Red, 2=Yellow (M√°quina)
    let vsComputer = false;
    let gameActive = true;
    
    // Configuraci√≥n de la IA
    // Profundidad de b√∫squeda: 1-3 (F√°cil/Medio), 4-5 (Dif√≠cil), 6+ (Muy Dif√≠cil / Lento)
    const AI_DEPTH = 4; 

    // Initialize board: 0 = empty, 1 = player 1 disk, 2 = player 2 disk
    function initBoard() {
        board = [];
        for(let r=0; r<ROWS; r++) {
            const row = [];
            for(let c=0; c<COLS; c++) {
                row.push(0);
            }
            board.push(row);
        }
    }

    // Draw empty board and disks
    function drawBoard() {
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        // Draw slots background
        ctx.fillStyle = '#0052cc';
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        // Draw slots and disks
        for(let r=0; r<ROWS; r++){
            for(let c=0; c<COLS; c++){
                const x = c * SLOT_SIZE + SLOT_SIZE/2;
                const y = (ROWS - 1 - r) * SLOT_SIZE + SLOT_SIZE/2;

                // Draw slot background: circle in blue
                ctx.beginPath();
                ctx.arc(x, y, RADIUS, 0, 2*Math.PI);
                ctx.fillStyle = '#003d99';
                ctx.fill();

                // Draw disk if any
                if(board[r][c] === 1) {
                    ctx.fillStyle = '#ff0000'; // Red
                } else if(board[r][c] === 2) {
                    ctx.fillStyle = '#ffff00'; // Yellow
                } else {
                    ctx.fillStyle = '#1a1a66'; // Empty slot darker circle inside
                    ctx.beginPath();
                    ctx.arc(x, y, RADIUS * 0.8, 0, 2*Math.PI);
                    ctx.fill();
                    continue;
                }

                ctx.beginPath();
                ctx.arc(x, y, RADIUS * 0.85, 0, 2*Math.PI);
                ctx.fill();
            }
        }
    }

    // *** FUNCI√ìN MODIFICADA ***
    // Get first empty row in a column, or -1 if full. Acepta tablero simulado.
    function getAvailableRow(col, boardToCheck = board) {
        for(let r = 0; r < ROWS; r++){
            if(boardToCheck[r][col] === 0){
                return r;
            }
        }
        return -1;
    }

    // Drop piece for player in column, return true if successful
    function dropPiece(col, player) {
        if(!gameActive) return false;
        const row = getAvailableRow(col);
        if(row === -1) return false;
        board[row][col] = player;
        return true;
    }
    
    // *** FUNCI√ìN MODIFICADA ***
    // Check horizontal, vertical and diagonal for 4 in a row. Acepta tablero simulado.
    function checkWin(player, boardToCheck = board) {
        // Horizontal
        for(let r=0; r<ROWS; r++){
            for(let c=0; c<=COLS-4; c++){
                if(boardToCheck[r][c] === player &&
                   boardToCheck[r][c+1] === player &&
                   boardToCheck[r][c+2] === player &&
                   boardToCheck[r][c+3] === player) return true;
            }
        }
        // Vertical
        for(let c=0; c<COLS; c++){
            for(let r=0; r<=ROWS-4; r++){
                if(boardToCheck[r][c] === player &&
                   boardToCheck[r+1][c] === player &&
                   boardToCheck[r+2][c] === player &&
                   boardToCheck[r+3][c] === player) return true;
            }
        }
        // Diagonal down-right
        for(let r=0; r<=ROWS-4; r++){
            for(let c=0; c<=COLS-4; c++){
                if(boardToCheck[r][c] === player &&
                   boardToCheck[r+1][c+1] === player &&
                   boardToCheck[r+2][c+2] === player &&
                   boardToCheck[r+3][c+3] === player) return true;
            }
        }
        // Diagonal up-right
        for(let r=3; r<ROWS; r++){
            for(let c=0; c<=COLS-4; c++){
                if(boardToCheck[r][c] === player &&
                   boardToCheck[r-1][c+1] === player &&
                   boardToCheck[r-2][c+2] === player &&
                   boardToCheck[r-3][c+3] === player) return true;
            }
        }
        return false;
    }


    // Check for draw (no empty slots)
    function checkDraw() {
        for(let c=0; c<COLS; c++){
            if(getAvailableRow(c) !== -1) return false;
        }
        return true;
    }

    // Show message in panel
    function showMessage(msg) {
        messageElem.textContent = msg;
    }

    // Update turn message
    function updateTurnMessage() {
        if(!gameActive) return;
        if(vsComputer) {
            showMessage(currentPlayer === 1 ? "Tu turno (Rojo)" : "Turno de la m√°quina (Amarillo)");
        } else {
            showMessage(`Turno jugador ${currentPlayer === 1 ? 'Rojo' : 'Amarillo'}`);
        }
    }

    // Switch player turn
    function switchTurn() {
        currentPlayer = 3 - currentPlayer;
        updateTurnMessage();
    }

    // Reset game state
    function resetGame() {
        initBoard();
        currentPlayer = 1;
        gameActive = true;
        showMessage('');
        updateTurnMessage();
        drawBoard();
    }


    // ------------------------------------------------------------------
    // -------- ALGORITMO MINIMAX (PARA AUMENTAR LA DIFICULTAD) ---------
    // ------------------------------------------------------------------

    // Puntuaci√≥n heur√≠stica simple: cuenta 2 en raya, 3 en raya, etc.
    function evaluateWindow(window, player) {
        let score = 0;
        const opp = 3 - player; 

        const player_count = window.filter(x => x === player).length;
        const empty_count = window.filter(x => x === 0).length;
        const opp_count = window.filter(x => x === opp).length;

        if (player_count === 4) {
            score += 100000; // ¬°Victoria!
        } else if (player_count === 3 && empty_count === 1) {
            score += 50; // 3 en raya con un hueco
        } else if (player_count === 2 && empty_count === 2) {
            score += 10; // 2 en raya con dos huecos
        }

        // Bloquea las amenazas del oponente
        if (opp_count === 3 && empty_count === 1) {
            score -= 5000; // Bloquea una posible victoria
        }

        return score;
    }

    // Funci√≥n principal de puntuaci√≥n de tablero
    function scorePosition(board, player) {
        let score = 0;

        // Puntuaci√≥n por control del centro (estrat√©gico)
        const center_col = Math.floor(COLS / 2);
        const center_array = board.map(r => r[center_col]);
        score += center_array.filter(x => x === player).length * 3;

        // Evaluar 4 casillas en todas las direcciones
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                // Horizontal
                if (c <= COLS - 4) {
                    score += evaluateWindow(board[r].slice(c, c + 4), player);
                }
                // Vertical
                if (r <= ROWS - 4) {
                    const window = [board[r][c], board[r + 1][c], board[r + 2][c], board[r + 3][c]];
                    score += evaluateWindow(window, player);
                }
                // Diagonal (Down-Right)
                if (c <= COLS - 4 && r <= ROWS - 4) {
                    const window = [board[r][c], board[r + 1][c + 1], board[r + 2][c + 2], board[r + 3][c + 3]];
                    score += evaluateWindow(window, player);
                }
                // Diagonal (Up-Right)
                if (c <= COLS - 4 && r >= 3) {
                    const window = [board[r][c], board[r - 1][c + 1], board[r - 2][c + 2], board[r - 3][c + 3]];
                    score += evaluateWindow(window, player);
                }
            }
        }
        return score;
    }

    // Algoritmo Minimax (Busca la mejor jugada asumiendo que el oponente tambi√©n juega √≥ptimamente)
    function minimax(currentBoard, depth, alpha, beta, maximizingPlayer) {
        const validCols = [];
        for(let i=0; i<COLS; i++){
            // Usamos la versi√≥n modificada de getAvailableRow
            if(getAvailableRow(i, currentBoard) !== -1) validCols.push(i);
        }
        
        // Condiciones terminales (fin del juego o profundidad m√°xima alcanzada)
        if (depth === 0 || checkWin(1, currentBoard) || checkWin(2, currentBoard) || validCols.length === 0) {
            if (checkWin(2, currentBoard)) return [null, 100000000000000]; // M√°quina gana
            if (checkWin(1, currentBoard)) return [null, -100000000000000]; // Jugador gana
            if (validCols.length === 0) return [null, 0]; // Empate
            
            return [null, scorePosition(currentBoard, 2)]; // Puntuaci√≥n heur√≠stica
        }

        if (maximizingPlayer) {
            let value = -Infinity;
            let best_col = validCols[Math.floor(Math.random() * validCols.length)]; // Movimiento aleatorio como fallback

            for (const col of validCols) {
                const tempBoard = JSON.parse(JSON.stringify(currentBoard)); // Crear copia profunda
                const row = getAvailableRow(col, tempBoard);
                tempBoard[row][col] = 2; // Simular jugada de la m√°quina

                const new_score = minimax(tempBoard, depth - 1, alpha, beta, false)[1];

                if (new_score > value) {
                    value = new_score;
                    best_col = col;
                }
                alpha = Math.max(alpha, value);
                if (alpha >= beta) break; // Alpha-Beta Pruning
            }
            return [best_col, value];
        } else { // Minimizing player (jugador 1)
            let value = Infinity;
            let best_col = validCols[Math.floor(Math.random() * validCols.length)];

            for (const col of validCols) {
                const tempBoard = JSON.parse(JSON.stringify(currentBoard));
                const row = getAvailableRow(col, tempBoard);
                tempBoard[row][col] = 1; // Simular jugada del jugador

                const new_score = minimax(tempBoard, depth - 1, alpha, beta, true)[1];

                if (new_score < value) {
                    value = new_score;
                    best_col = col;
                }
                beta = Math.min(beta, value);
                if (alpha >= beta) break; // Alpha-Beta Pruning
            }
            return [best_col, value];
        }
    }

    // L√≥gica del turno de la m√°quina (sustituye a simpleAIPlay)
    async function aiTurn() {
        if(!gameActive || currentPlayer !== 2) return;
        showMessage('Turno de la m√°quina...');
        
        // Ejecutar Minimax para encontrar el mejor movimiento
        const [best_col, score] = minimax(board, AI_DEPTH, -Infinity, Infinity, true); 

        // Retardo simulado para que parezca que la m√°quina "piensa"
        await new Promise(resolve => setTimeout(resolve, 600)); 

        if(best_col !== null && dropPiece(best_col, 2)){
            drawBoard();
            if(checkWin(2)) {
                gameActive = false;
                showMessage('La m√°quina gana. ¬°Fin del juego! üò≠');
                notifyParent(false);
                return;
            }
            if(checkDraw()) {
                gameActive = false;
                showMessage('Empate. ¬°Fin del juego!');
                notifyParent(null);
                return;
            }
            switchTurn();
        }
    }
    // ------------------------------------------------------------------
    // -------------------- FIN C√ìDIGO MINIMAX --------------------------
    // ------------------------------------------------------------------


    // Notify parent frame about game end, with fallback
   function notifyParent(playerWon) {
    // Par√°metro true si gan√≥ jugador, false si m√°quina, null empate
    setTimeout(() => {
        let parentNotified = false;
        
        try {
            // 1. Intenta notificar al programa padre (si existe la funci√≥n endGame)
            if(window.parent && window.parent !== window && typeof window.parent.endGame === 'function'){
                window.parent.endGame(playerWon === true);
                parentNotified = true;
            }
        } catch(e) {
            // Error de seguridad o acceso
            console.error("Error al notificar al programa padre:", e);
        } finally {
            // 2. Si fall√≥ la notificaci√≥n al padre (o si se ejecuta en solitario), 
            // forzamos la redirecci√≥n (comportamiento original para "regresar").
            if (!parentNotified) {
                // Esta es la l√≠nea clave que "regresa" o "reinicia" el contenedor padre.
                window.location.href = '/'; 
            }
        }
    }, 2500); // 2.5 segundos de espera
}

    // Handle user clicking on board to place disk
    function handleClick(event) {
        if(!gameActive || currentPlayer !== 1) return;
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const colClicked = Math.floor(x / SLOT_SIZE);
        if(colClicked < 0 || colClicked >= COLS) return;
        if(dropPiece(colClicked, 1)){
            drawBoard();
            if(checkWin(1)){
                gameActive = false;
                showMessage('¬°Has ganado! üéâ');
                notifyParent(true);
                return;
            }
            if(checkDraw()){
                gameActive = false;
                showMessage('Empate. Fin del juego.');
                notifyParent(null);
                return;
            }
            switchTurn();
            // Llama a la IA para su turno
            if(vsComputer) {
                aiTurn();
            }
        }
    }

    // Touch support: treat touch as click for simplicity
    canvas.addEventListener('touchstart', e => {
        if(e.touches.length === 1){
            handleClick(e.touches[0]);
        }
    });

    // Mouse support
    canvas.addEventListener('click', handleClick);

    // Buttons for mode selection
    btnPvP.addEventListener('click', () => {
        // Permitir cambiar modo solo si el juego est√° inactivo o al inicio
        if (gameActive) return; 
        vsComputer = false;
        btnPvP.setAttribute('aria-pressed', 'true');
        btnPvC.setAttribute('aria-pressed', 'false');
        showMessage('Modo 2 Jugadores activado');
        resetGame();
    });
    btnPvC.addEventListener('click', () => {
        // Permitir cambiar modo solo si el juego est√° inactivo o al inicio
        if (gameActive) return; 
        vsComputer = true;
        btnPvP.setAttribute('aria-pressed', 'false');
        btnPvC.setAttribute('aria-pressed', 'true');
        showMessage('Modo Jugador vs M√°quina activado');
        resetGame();
    });

    // On load initialize PvC by default
    vsComputer = true;
    btnPvC.setAttribute('aria-pressed', 'true');
    btnPvP.setAttribute('aria-pressed', 'false');
    resetGame();
})();
</script>

</body>
</html>
